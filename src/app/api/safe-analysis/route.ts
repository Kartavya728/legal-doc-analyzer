// /app/api/safe-analysis/route.ts

import { NextResponse } from 'next/server';
import { pipeline, Pipeline } from '@xenova/transformers';
import pdf from 'pdf-parse';

/**
 * Extracts text from a file.
 */
async function extractText(file: File): Promise<string> {
  if (file.type === 'application/pdf') {
    const fileBuffer = await file.arrayBuffer();
    const data = await pdf(Buffer.from(fileBuffer));
    return data.text;
  }
  return await file.text();
}

// --- Singleton Pattern for the Instruction-Following Model ---
// We use a more capable model that's good at following structured prompts.
class GenerationPipeline {
  static task = 'text2text-generation';
  static model = 'Xenova/flan-t5-small'; // Excellent for instruction-based tasks
  static instance: Pipeline | null = null;

  static async getInstance(progress_callback?: Function) {
    if (this.instance === null) {
      console.log("‚è≥ Initializing local instruction model for the first time...");
      this.instance = await pipeline(this.task, this.model, { progress_callback });
      console.log("‚úÖ Local model initialized successfully.");
    }
    return this.instance;
  }
}

export async function POST(request: Request) {
  console.log("\n\n--- [POST /api/safe-analysis] - Request received ---");
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File | null;
    if (!file) {
      return NextResponse.json({ error: 'A file is required.' }, { status: 400 });
    }

    // Step 1: Extract text. The full text will be passed to the chatbot.
    const documentText = await extractText(file);
    if (!documentText) {
      return NextResponse.json({ error: 'Failed to extract text from the file.' }, { status: 500 });
    }
    console.log("‚úÖ Successfully extracted text.");

    // Step 2: Get the initialized local model
    const generator = await GenerationPipeline.getInstance();

    // Step 3: Create a prompt that asks for the exact JSON structure needed
    const prompt = `
      Based on the following document, generate a JSON object with two keys:
      1. "summaryText": A concise summary of the document.
      2. "importantPoints": An array of the 3 to 5 most important bullet points.

      DOCUMENT: """
      ${documentText.substring(0, 4000)}
      """

      JSON:
    `;

    // Step 4: Perform the generation
    console.log("‚è≥ Performing safe analysis (summary & key points)...");
    const output = await generator(prompt, {
      max_new_tokens: 500, // Max length of the generated JSON string
      temperature: 0.5,
      do_sample: true,
    });

    const generatedText = Array.isArray(output) ? output[0].generated_text : output.generated_text;
    console.log("--- RAW MODEL OUTPUT --- \n", generatedText);
    
    // Step 5: Parse the JSON string generated by the model
    const generatedJson = JSON.parse(generatedText);

    // Step 6: Construct the final response object to match what Display.tsx expects
    const finalResponse = {
      // This 'summary' object contains the fields needed by SummaryCard and KeyPoints
      summary: {
        summaryText: generatedJson.summaryText,
        importantPoints: generatedJson.importantPoints,
      },
      // We include the full document text so the Chatbot has context
      fullText: documentText,
    };
    
    console.log("‚úÖ Analysis complete. Sending structured data to frontend.");
    return NextResponse.json(finalResponse);

  } catch (error) {
    console.error("\nüî¥üî¥üî¥ FATAL ERROR in /api/safe-analysis üî¥üî¥üî¥", error);
    return NextResponse.json({ error: 'Failed to perform safe analysis.' }, { status: 500 });
  }
}